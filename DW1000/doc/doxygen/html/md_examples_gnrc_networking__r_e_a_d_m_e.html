<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>gnrc_networking example</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="riot-logo.png"/></td>
    <td style="padding-left: 0.5em;">
    <div id="projectbrief">DecaRange RTLS ARM Application</div>
    </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">gnrc_networking example </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This example shows you how to try out the code in two different ways: Either by communicating between the RIOT machine and its Linux host, or by communicating between two RIOT instances. Note that the former only works with native, i.e. if you run RIOT on your Linux machine.</p>
<h2>Connecting RIOT native and the Linux host</h2>
<blockquote class="doxtable">
<p><b>Note:</b> RIOT does not support IPv4, so you need to stick to IPv6 anytime. To </p>
</blockquote>
<p>establish a connection between RIOT and the Linux host, you will need <code>netcat</code> (with IPv6 support). Ubuntu 14.04 comes with netcat IPv6 support pre-installed. On Debian it's available in the package <code>netcat-openbsd</code>. Be aware that many programs require you to add an option such as -6 to tell them to use IPv6, otherwise they will fail. If you're using a <em>Raspberry Pi</em>, run <code>sudo modprobe ipv6</code> before trying this example, because raspbian does not load the IPv6 module automatically. On some systems (openSUSE for example), the <em>firewall</em> may interfere, and prevent some packets to arrive at the application (they will however show up in Wireshark, which can be confusing). So be sure to adjust your firewall rules, or turn it off (who needs security anyway).</p>
<p>First, create a tap interface: </p><pre class="fragment">sudo ip tuntap add tap0 mode tap user ${USER}
sudo ip link set tap0 up
</pre><p>Now you can start the <code>gnrc_networking</code> example by invoking <code>make term</code>. This should automatically connect to the <code>tap0</code> interface. If this doesn't work for any reason, run make term with the tap0 interface as the PORT environment variable: </p><pre class="fragment">PORT=tap0 make term
</pre><p>To verify that there is connectivity between RIOT and Linux, go to the RIOT console and run <code>ifconfig</code>: </p><pre class="fragment">&gt; ifconfig
Iface  7   HWaddr: ce:f5:e1:c5:f7:5a
           inet6 addr: ff02::1/128  scope: local [multicast]
           inet6 addr: fe80::ccf5:e1ff:fec5:f75a/64  scope: local
           inet6 addr: ff02::1:ffc5:f75a/128  scope: local [multicast]
</pre><p>Copy the <a href="https://en.wikipedia.org/wiki/Link-local_address">link-local address</a> of the RIOT node (prefixed with <code>fe80</code>) and try to ping it <b>from the Linux node</b>: </p><pre class="fragment">ping6 fe80::ccf5:e1ff:fec5:f75a%tap0
</pre><p>Note that the interface on which to send the ping needs to be appended to the IPv6 address, <code>tap0</code> in the above example. When talking to the RIOT node, you always want to send to/receive from the <code>tap0</code> interface.</p>
<p>If the pings succeed you can go on to send UDP packets. To do that, first start a UDP server on the RIOT node: </p><pre class="fragment">&gt; udp server start 8808
Success: started UDP server on port 8808
</pre><p>Now, on the Linux host, you can run netcat to connect with RIOT's UDP server: </p><pre class="fragment">nc -6uv fe80::ccf5:e1ff:fec5:f75a%tap0 8808
</pre><p>The <code>-6</code> option is necessary to tell netcat to use IPv6 only, the <code>-u</code> option tells it to use UDP only, and the <code>-v</code> option makes it give more verbose output (this one is optional).</p>
<p>You should now see that UDP messages are received on the RIOT side. Opening a UDP server on the Linux side is also possible. To do that, write down the IP address of the host (run on Linux): </p><pre class="fragment">ifconfig tap0
tap0     Link encap:Ethernet  HWaddr ce:f5:e1:c5:f7:59
        inet6 addr: fe80::4049:5fff:fe17:b3ae/64 Scope:Link
        UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
        RX packets:6 errors:0 dropped:0 overruns:0 frame:0
        TX packets:36 errors:0 dropped:0 overruns:0 carrier:0
        collisions:0 txqueuelen:0
        RX bytes:488 (488.0 B)  TX bytes:3517 (3.5 KB)
</pre><p>Then open a UDP server on Linux (the <code>-l</code> option makes netcat listen for incoming connections): </p><pre class="fragment">nc -6ul 8808
</pre><p>Now, on the RIOT side, send a UDP packet using: </p><pre class="fragment">udp send fe80::4049:5fff:fe17:b3ae 8808 testmessage
</pre><p>You should see <code>testmessage</code> appear in netcat. Instead of using netcat, you can of course write your own software, but you may have to bind the socket to a specific interface (tap0 in this case). For an example that shows how to do so, see <a href="https://gist.github.com/backenklee/dad5e80b764b3b3d0d3e">here</a>.</p>
<h2>Connecting two RIOT instances</h2>
<p>When using native (i.e. when you're trying this on your Linux machine), you first need to set up two tap devices and a bridge that connects them. This constitutes a virtual network that the RIOT instances can use to communicate. </p><pre class="fragment">./../../dist/tools/tapsetup/tapsetup --create 2
</pre><p>Then, make sure you've compiled the application by calling <code>make</code> and start the first RIOT instance by invoking <code>make term</code>. In the RIOT shell, get to know the IP address of this node: </p><pre class="fragment">&gt; ifconfig
Iface  7   HWaddr: ce:f5:e1:c5:f7:5a
           inet6 addr: ff02::1/128  scope: local [multicast]
           inet6 addr: fe80::ccf5:e1ff:fec5:f75a/64  scope: local
           inet6 addr: ff02::1:ffc5:f75a/128  scope: local [multicast]
</pre><p>and start a UDP server. </p><pre class="fragment">&gt; udp server start 8808
</pre><p>This node is now ready to receive data on port <code>8808</code>.</p>
<p>In a second terminal, start a second RIOT instance, this time listening on <code>tap1</code>: </p><pre class="fragment">PORT=tap1 make term
</pre><p>In the RIOT shell, you can now send a message to the first RIOT instance: </p><pre class="fragment">&gt; udp send fe80::ccf5:e1ff:fec5:f75 8808 testmessage
</pre><p>*(Make sure to copy the actual <a href="https://en.wikipedia.org/wiki/Link-local_address">link-local address</a> of your first RIOT instance into the above command)*</p>
<p>In your first terminal, you should now see output that looks like this. </p><pre class="fragment">&gt; PKTDUMP: data received:
~~ SNIP  0 - size:  11 byte, type: NETTYPE_UNDEF (0)
000000 74 65 73 74 6d 65 73 73 61 67 65
~~ SNIP  1 - size:   8 byte, type: NETTYPE_UDP (3)
   src-port:  8808  dst-port:  8808
   length: 19  cksum: 0x4d95f
~~ SNIP  2 - size:  40 byte, type: NETTYPE_IPV6 (1)
traffic class: 0x00 (ECN: 0x0, DSCP: 0x00)
flow label: 0x00000
length: 19  next header: 17  hop limit: 64
source address: fe80::a08a:84ff:fe68:544f
destination address: fe80::60fc:3cff:fe5e:40df
~~ SNIP  3 - size:  20 byte, type: NETTYPE_NETIF (-1)
if_pid: 6  rssi: 0  lqi: 0
src_l2addr: a2:8a:84:68:54:4f
dst_l2addr: 62:fc:3c:5e:40:df
~~ PKT    -  4 snips, total size:  79 byte</pre> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon May 15 2017 18:50:48 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
